안티그래비티 개발 지침서
주제: localStorage 용량 한계 문제를 해결하기 위한 Supabase 중심 데이터 저장 구조 전환

1. 문서 목적

이 문서는 안티그래비티 에이전트가 현재 프로젝트의 전체 코드/파일 구조를 이해한 상태에서,
다음 목표를 달성하기 위해 어떤 방향과 역할로 작업을 진행해야 하는지 안내하기 위한 상위 개념 지침이다.

- 목표: localStorage에 과도한 데이터를 저장하여 발생하는 QuotaExceededError 및 유사 문제를 근본적으로 제거한다.
- 방법: “데이터 크기가 커지거나 커질 가능성이 높은 부분”을 Supabase(또는 서버/DB) 기반 저장 방식으로 전환하고,
  localStorage는 비교적 작고 가벼운 상태값만 저장하는 보조 도구로 제한한다.
- 결과: 대형 프로젝트(긴 스크립트, 많은 장면, 장시간 오디오/비디오)를 안정적으로 처리할 수 있는 구조를 만든다.

이 문서는 구체적인 코드 구현이 아니라,
“왜 이 작업을 하는지 / 어떤 원칙으로 움직여야 하는지 / 어떤 흐름으로 코드를 바꿔야 하는지”에 집중한다.


2. 현재 문제 인식

2-1. localStorage의 근본 한계

- 브라우저 localStorage는 대략 5MB 정도의 저장 용량 제한이 있으며,
  이는 브라우저/환경마다 조금씩 다를 수 있다.
- 스크립트, 장면(Scene) 배열, 프롬프트(JSON), 자동화 설정, 메타데이터 등이
  한 번에 localStorage에 저장될 경우, 프로젝트가 커질수록 쉽게 이 한계를 초과한다.
- 특히, “프로젝트 단위 상태를 통째로 JSON으로 직렬화해서 localStorage에 setItem 하는 패턴”은
  데이터 양이 많아질수록 QuotaExceededError의 직접적인 원인이 된다.

2-2. 실제로 발생한 문제

- editablePrompts_… 형태의 키로 매우 큰 JSON 데이터가 localStorage에 저장되면서,
  다음과 같은 오류가 발생했다.
  - Uncaught QuotaExceededError: Failed to execute 'setItem' on 'Storage': Setting the value of 'editablePrompts_…' exceeded the quota.
- 이 오류는 단순한 예외가 아니라, “현재 앱의 데이터 저장 전략이 크기 확장에 적합하지 않다”는 신호이다.
- 앞으로 더 긴 스크립트, 더 많은 장면, 더 많은 자동화가 추가될수록 같은 문제가 반복될 수밖에 없다.


3. 안티그래비티의 역할과 작업 방향

3-1. 역할 개요

안티그래비티는 “파일 구조를 전체적으로 파악하고, 그 위에 설계와 리팩토링을 수행하는 에이전트”로서,
다음 역할을 수행해야 한다.

1) 전체 코드베이스 분석
   - 프로젝트의 폴더/파일 구조를 스캔하고,
   - 어디에서 어떤 형태로 localStorage를 사용하는지 전수 조사한다.
   - 특히, “크기가 커질 수 있는 데이터”를 localStorage에 직접 저장하는 패턴을 집중적으로 찾는다.

2) 데이터 흐름(워크플로우) 파악
   - 스크립트 생성 → 장면 분할 → 오디오/이미지/비디오 생성 → 자동 저장/라이브러리 저장
   - 이런 전체 워크플로우 중에서, 데이터가 크게 쌓일 수 있는 지점들을 파악한다.
   - 예: 장면 리스트, 장면별 프롬프트, 자동화 설정, 결과 메타데이터 등

3) 저장 전략 재설계
   - “어떤 데이터는 Supabase에 저장해야 하는지, 어떤 데이터는 localStorage에 남길 수 있는지”를 구분하는 기준을 정의한다.
   - 이 기준을 토대로, 기존 코드를 Supabase 중심 구조로 점진적으로 옮기는 계획을 세운다.

4) 리팩토링 및 일관성 유지
   - Supabase 저장/조회 API를 기준으로 프론트엔드 상태 관리 로직을 리팩토링한다.
   - 동시에 기존 기능(스크립트 생성, 오디오/이미지/비디오 생성, 라이브러리 재생 등)이 깨지지 않도록 일관성을 유지한다.


3-2. 구체적인 작업 흐름(고수준)

안티그래비티는 다음과 같은 순서와 흐름으로 작업을 진행해야 한다.

(1) 전체 파일 구조 및 저장 코드 검색
    - 전 프로젝트에서 다음 키워드로 검색:
      - localStorage.setItem
      - localStorage.getItem
      - editablePrompts
      - scene / scenes / script / prompts 와 함께 쓰이는 저장 코드
    - 각 사용 위치별로:
      - 어떤 데이터 구조를 저장하는지,
      - 이 데이터의 크기가 프로젝트 확장 시 얼마나 커질 수 있는지,
      - 이 데이터가 휘발성이어도 되는지(임시 값인지), 아니면 영구 보존이 필요한지 파악한다.

(2) “대용량 후보 데이터” 분류
    - 다음과 같은 데이터는 대용량/확장 후보로 분류한다.
      - 전체 스크립트 텍스트
      - 장면(Scene) 배열 및 장면별 설정
      - 이미지/비디오 생성용 프롬프트 묶음
      - 완전자동화(OneClick/Auto) 설정 JSON (추후)
      - 프로젝트 단위로 커질 수 있는 모든 상태 값
    - 이 데이터들은 localStorage가 아닌, Supabase(또는 서버 DB)에 저장해야 한다.

(3) “경량 데이터” 분류
    - 다음과 같은 데이터는 localStorage에 남길 수 있다.
      - 마지막으로 열었던 프로젝트 ID
      - UI 테마(다크/라이트), 언어, 레이아웃 같은 순수 UI 상태
      - 소량의 필터/정렬 옵션
      - key값 등
    - 이들은 크기가 매우 작고, 유저 경험 향상을 위한 보조 정보에 가깝다.

(4) Supabase 중심 저장 구조로 변경
    - 대용량 데이터에 대해서는:
      - Supabase의 테이블 또는 JSON 컬럼을 활용해 서버 측 영구 저장소에 저장하도록 변경한다.
      - 프론트엔드는 저장/불러오기 시 “localStorage가 아니라 Supabase API를 통해” 데이터를 주고받도록 흐름을 전환한다.
    - 이 과정에서:
      - 자동 저장(auto-save) 로직이 있다면 Supabase 기준으로 재구성한다.
      - 초기 로딩 시에는 Supabase에서 데이터 로드 후, React/Zustand 등 상태에 반영한다.

(5) 기존 localStorage 데이터 마이그레이션
    - 이미 localStorage에 남아 있는 대량 데이터가 있다면:
      - 첫 진입 시, 해당 데이터를 Supabase로 옮기고(local → server),
      - 성공적으로 저장되면 localStorage에서 제거하는 마이그레이션 루틴을 구현한다.
    - 이로써 기존 사용자 데이터도 자연스럽게 서버 기반 구조로 이전된다.

(6) localStorage 사용 최소화 및 안전 가드
    - 남아 있는 localStorage 사용 코드에 대해서도:
      - 저장 전 길이 제한/예외 처리 가드를 두어, 우발적인 대량 저장을 방지한다.
      - 예: 너무 큰 JSON을 저장하려 할 경우 저장하지 않고 경고 로그만 남기기.
    - 장기적으로는 “중요한 데이터는 서버, 보조적인 UI 상태만 localStorage”라는 원칙을 유지한다.


4. 개발 의도 및 방향성

4-1. 개발 의도

- 이 작업의 핵심 의도는 “대용량 콘텐츠 자동화”라는 앱의 본질적인 방향성에 맞는 안정적인 데이터 저장 구조를 갖추는 것이다.
- 사용자는 앞으로:
  - 더 긴 스크립트,
  - 더 많은 장면과 프롬프트,
  - 더 많은 자동 생성 옵션,
  - 더 긴 오디오/비디오 프로젝트를 다루게 될 가능성이 크다.
- 이러한 상황에서 localStorage 기반 저장 구조는 필연적으로 한계에 부딪치며,
  사용자 경험을 해치는 예외와 크래시를 반복적으로 발생시킬 수 있다.
- 따라서, **현재 시점에서 “Supabase 중심 구조로의 전환”은 선택이 아니라 필수적인 리팩토링**이다.

4-2. 개발 방향의 핵심 키워드

- “클라이언트 저장에서 서버 저장으로”
- “상태 전체를 localStorage에 넣지 말고, 서버/DB에 구조적으로 쌓기”
- “프로젝트/장면/프롬프트 기반의 도메인 중심 데이터 모델링”
- “PC/모바일/다른 브라우저 어디서나 동일한 프로젝트를 이어서 작업 가능하게 만들기”


5. 이번 리팩토링으로 얻는 장점

5-1. 기술적 장점

1) QuotaExceededError 및 localStorage 관련 예외의 근본 제거
   - 더 이상 데이터 크기 때문에 앱이 로딩 시점에서 크래시 나지 않는다.
   - 긴 프로젝트, 대형 프로젝트에서도 안정적인 동작 보장.

2) 대형/장기 프로젝트 지원
   - 5분짜리가 아니라 30분, 1시간 이상의 스크립트/오디오/비디오도
     구조적으로 저장/복구 가능하다.
   - 나중에 “프로젝트 복원, 버전 관리, 진행 중 작업 이어서 하기” 기능 확장도 용이해진다.

3) 서버 기반 자동화 워크플로우와 자연스러운 통합
   - 앞으로 구현할 완전자동화(OneClick 전체 파이프라인, FFmpeg 기반 합성 등)는
     기본적으로 서버/워커/큐 기반 구조 위에서 동작하게 된다.
   - 그때도 같은 데이터 모델(Supabase에 저장된 프로젝트/씬/프롬프트)을 그대로 활용할 수 있어,
     구조가 단순해지고 유지보수가 쉬워진다.

5-2. 사용자 경험(UX) 측 장점

1) 어느 기기에서나 이어서 작업 가능
   - PC에서 작업하다가, 이동 중 모바일에서 스크립트/설정만 만지고,
     다시 PC에서 이어서 자동 생성/편집을 할 수 있다.
   - localStorage에 의존하지 않으므로, 브라우저를 바꿔도 프로젝트가 그대로 유지된다.

2) 대형 프로젝트에서도 앱이 “느려지거나, 갑자기 죽는” 경험 감소
   - 저장 때문에 앱이 멈추는 느낌 대신, 단계별 저장/자동 저장이 더 예측 가능해진다.

3) 라이브러리와 자동 생성 기능의 신뢰도 증가
   - “이 프로젝트 저장된 거 맞나?”, “다음에 들어와도 그대로 있을까?” 같은 불안이 줄어든다.


6. 안티그래비티에게 요구하는 최종 태도

- 이 작업은 단순 버그 픽스 수준이 아니라,
  **앱의 장기적인 성장 방향을 고려한 “저장 구조 리디자인”**이다.
- 안티그래비티는 전체 파일/코드 구조를 이해하는 능력을 바탕으로:
  - 어느 부분에서 데이터가 생성/수정/저장되는지,
  - 그 데이터가 얼마나 커질 수 있는지,
  - 그 데이터가 “세션 한 번”에만 필요한지, 아니면 “프로젝트 생명주기 전체”에서 필요한지,
  를 판단하여 적절한 저장소(Supabase vs localStorage)를 선택해야 한다.
- 항상 다음 질문을 스스로에게 던지며 작업을 진행해야 한다.
  - “이 데이터는 프로젝트가 커져도 안전한가?”
  - “이 데이터를 브라우저 한 기기에만 묶어두면, 나중에 문제가 되지 않을까?”
  - “이 데이터는 서버에 있어야 나중에 자동화/렌더링/백업 등에서 재사용하기 좋지 않을까?”

이 문서의 목적은, 안티그래비티가 이러한 관점을 갖고
“localStorage → Supabase 중심 구조 전환”이라는 큰 리팩토링을
일관된 방향과 명확한 의도를 가지고 수행하도록 돕는 것이다.
