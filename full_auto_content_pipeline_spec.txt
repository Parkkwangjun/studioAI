# 완전자동화 콘텐츠 생성 시스템 개발 지침서 (Antigravity / Cursor용)

> 이 파일은 **안티그래비티(Antigravity) / Cursor 에이전트**가 읽고,  
> 기존 앱 구조를 유지한 상태에서 **“완전자동화 콘텐츠 생성 기능”**을 구현하기 위한 **전체 개발 계획서**입니다.  
> 이 문서 하나만으로 개발자가 전체 구조를 이해하고 개발을 진행할 수 있도록 최대한 구체적으로 작성했습니다.

---

## 0. 개발 사전 배경

### 0.1 개발 의도 / 이유

- 사용자는 이미 다음 기능이 구현된 **웹앱**을 운영 중이다.
  - 스크립트 생성 (GPT API)
  - 오디오 생성 (Google TTS API)
  - 이미지 생성 (이미지 생성 API)
  - 비디오 생성 (kie.ai 서비스에 있는 비디오 생성 API 등)
  - Supabase를 통한 **프로젝트/워크스페이스 데이터 관리 및 파일 저장**
- 현재는 각 단계를 **사용자가 수동으로 순서대로 클릭**해야 한다.
  - 스크립트 생성 → 오디오 생성 → 이미지 생성 → 비디오 생성 → 외부 편집 툴에서 합성
- 목표는:
  - 사용자가 **“자동 생성(One Click)” 버튼만 누르면**
  - 장면 단위로 **스크립트 → 오디오 → 이미지 → 비디오(옵션)**가 순차적으로 생성되고
  - 이미지 또는 비디오를 생성할 때는 GPT로 프롬프트 가공이 들어가면서 각 단계에서 퀄리티있는 결과물을 도출한다.
  - FFmpeg 기반으로 **오디오 길이에 이미지 길이 또는 비디오(옵션) 길이를 자동 맞추고**
  - 모든 장면이 장면 순서대로 이어진 **최종 하나의 비디오 파일**까지 자동으로 만들어지는 시스템을 구축하는 것.
  - 기본적으로 완전자동화의 핵심은 추후 편집이 용이하고, 합리적인 비용으로 컨텐츠를 제작하는데 의의를 둔다.
  - 롱폼의 경우 모든 씬을 비디오 생성하면 API 호출비용이 상당하므로 비디오 생성은 토글 스위치 옵션으로 생성 유무를 선택할 수 있다.
  - 비디오 생성이 OFF 시 오디오의 길이를 기준으로 순차적으로 이어붙여진 이미지 슬라이드를 오디오의 길이에 맞춰서 싱크를 맞춘 후 최종 렌더링 mp4파일로 내보낸다.

### 0.2 핵심 목표

1. **기존 기능/코드 절대 훼손 금지**
   - 이미 동작 중인 스크립트/오디오/이미지/비디오 API 연동 코드는 **그대로 재사용**해야 한다.
   - 기존 기능 삭제, 변경, 파괴적 수정 금지.
   - 새로운 기능은 **“추가 레이어/모듈”**로 올려서 연결하는 방식.

2. **완전자동화 파이프라인 구축**
   - “완전자동 생성”을 위한 **별도의 워크플로우/잡 시스템**을 추가한다.
   - 각 단계를 자동으로 실행하고, 상태를 추적하며, 에러 시 복구/재시도 가능해야 한다.

3. **모바일에서도 동일한 자동화 사용 가능**
   - 앱은 **웹앱** 으로 동작하며,
   - URL 접속시 PC/모바일 어디서든 **같은 자동화 기능**을 사용할 수 있도록 한다.
   - 모바일에서는 주로:
     - 스크립트 입력/수정
     - 자동 생성 버튼 실행
     - 진행 상황 확인
   - 최종 비디오 다운로드는 주로 PC에서 사용하되, **기능상 제약은 두지 않는다.**

---

## 1. 전체 아키텍처 개요

### 1.1 개념 구조

- **Frontend (웹앱, PC + Mobile Web)**
  - Project / Workspace UI
  - “완전자동 생성” 설정 패널
  - 진행 상태(Progress) 표시
  - 최종 결과물/로그 확인 및 다운로드 버튼

- **Backend API (Next.js API Route 또는 별도 서버)**
  - `/api/auto/run` : 자동 생성 파이프라인 시작
  - `/api/auto/status/:jobId` : 작업 상태 조회
  - `/api/auto/cancel/:jobId` : 작업 취소(선택 사항)
  - 내부에서 **Queue + Worker(예: BullMQ)** 를 통해 장기 작업 처리

- **Worker (Rendering / Generation Worker)**
  - Queue에서 Job 소비
  - 장면 단위 파이프라인 실행:
    - Scene 분할
    - TTS 생성
    - 이미지 생성
    - 비디오 생성(옵션)
    - FFmpeg로 오디오/이미지 또는 비디오(옵션) 싱크 조정
  - 최종 Full Video 렌더링 및 Supabase 업로드

- **Storage (Supabase)**
  - 프로젝트/장면 메타데이터
  - 스크립트/오디오/이미지/비디오 파일
  - Job 상태 및 로그 저장

### 1.2 도메인 모델 (개념)

```json
{
  "Workspace": {
    "id": "string",
    "name": "string"
  },
  "Project": {
    "id": "string",
    "workspaceId": "string",
    "title": "string",
    "channelType": "string",  // ex) "history_korea", "kids", "cctv_horror"
    "aspectRatio": "string",  // ex) "16:9", "9:16"
    "stylePresetId": "string", 
    "scriptId": "string",
    "autoConfigId": "string|null"
  },
  "Script": {
    "id": "string",
    "projectId": "string",
    "rawText": "string",         // 전체 스크립트 원본
    "scenes": [
      {
        "sceneId": 1,
        "title": "string",
        "text": "string",         // 장면별 내레이션 텍스트
        "visualHint": "string"    // 선택사항: 장면 설명
      }
    ]
  },
  "AutoConfig": {
    "id": "string",
    "projectId": "string",
    "ttsVoice": "string",
    "ttsSpeed": 1.0,
    "imageStylePresetId": "string",
    "videoStylePresetId": "string",
    "maxSceneCount": 150,
    "testMode": false
  },
  "SceneAsset": {
    "sceneId": 1,
    "audioId": "string|null",
    "audioDurationSec": 0,
    "imageId": "string|null",
    "videoId": "string|null",
    "videoDurationSec": 0
  },
  "AutoJob": {
    "id": "string",
    "projectId": "string",
    "status": "PENDING|RUNNING|FAILED|COMPLETED|CANCELLED",
    "currentStep": "NONE|SCRIPT_SEGMENT|TTS|IMAGE|VIDEO|SYNC|FINAL_RENDER",
    "progress": 0,           // 0~100
    "error": "string|null",
    "createdAt": "string",
    "updatedAt": "string",
    "logs": []
  }
}
```

---

## 2. 정보 구조 & 워크플로우

### 2.1 사용자 상위 흐름 (UX 플로우)

1. **프로젝트 선택/생성**
   - Workspace 내에서 Project를 선택하거나 새로 생성.

2. **기존 스크립트 확보**
   - 이미 구현되어 있는 **스크립트 생성 기능**을 사용해 스크립트를 만든다.
   - 또는 외부에서 만든 스크립트를 그대로 붙여넣는다.
   - 스크립트는 내부적으로 **장면(Scene) 단위**로 분할 및 저장.
   - 장면 단위의 스크립트 분할은 오디오의 분량 약 5~10초 내외정도로 분할한다.

3. **자동 생성 설정 (AutoConfig)**
   - TTS 설정
     - 음성(voice)
     - 속도(speed)
   - 이미지 스타일 프리셋
     - 예: 
       - `history_korea_anime_dark_line`
       - `kids_cartoon_pastel`
   - 비디오 스타일 프리셋
     - Seedream 프롬프트 공통 부분
   - 화면 비율(aspectRatio)
     - 16:9 / 9:16 / 1:1 등
   - **테스트 모드(testMode)**: 
     - ON이면 **앞 1~2개의 장면만** 생성해서 샘플 확인 후 전체 실행.
   - **비디오 생성모드**
     - 토글 스위치 ON 모드 일경우에만 이미지-투-비디오로 비디오를 생성한다.

4. **“완전자동 생성” 버튼 클릭**
   - `/api/auto/run` 호출 → AutoJob 생성 → Queue에 Job 등록
   - UI에는 Job ID 기반으로 상태 폴링(**SSE 또는 polling**)로 진행률 표시
   - 사용자가 넣은 스크립트를 GPT api가 스크립트를 분석 및 자동 분할 진행. (오디오 음성 기준 약 5~10초내외 문장으로 나눈다. 분할기준은 줄바꿈으로 장면을 분할하고 고유ID로 식별할 수 있도록 한다.)
   - 스크립트 장면 분할 완료 후 GPT api가 각 장면의 스크립트를 분석하고 해당 장면에 맞는 visualHint를 생성한다. (visualHint는 전체 스크립트의 전체 스토리의 맥락을 파악하고, 분석한 장면에서 시청자가 스토리의 맥락을 이해할 수 있는, 납득이 가는, 시청자가 보고싶은 장면을 묘사해야하고 이미지를 생성하기 위한 핵심 프롬프트로 이미지 생성에 가장 정교한 품질을 요청할 수 있는 JSON기반 프롬프트로 생성한다.)

-이미지 JSON 프롬프트 예시:
```json
{
  "media_type": "image",
  "version": 1,
  "goal": "A cinematic close-up portrait of a woman holding an umbrella in the neon-lit rainy city.",
  "description": {
    "narrative": "A woman stands in the rain under a transparent umbrella, illuminated by colorful neon reflections.",
    "subject": "Young woman with a visibly sad expression, raindrops on her face, holding a clear umbrella.",
    "environment": "Nighttime urban street with neon signs, wet pavement reflecting vivid colors.",
    "mood": "Melancholic, cinematic, reflective."
  },
  "composition": {
    "shot_type": "close-up",
    "camera_angle": "eye-level",
    "framing": "rule-of-thirds",
    "perspective": "1-point",
    "subject_distance": "close"
  },
  "camera": {
    "lens": "85mm portrait lens",
    "focal_length_mm": 85,
    "aperture": "f/1.8",
    "focus": "eyes and facial expression",
    "depth_of_field": "shallow",
    "aspect_ratio": "16:9"
  },
  "lighting": {
    "time_of_day": "night",
    "light_source": "neon signs and street reflections",
    "light_direction": "side",
    "contrast": "soft contrast",
    "color_temperature": "cool",
    "weather": "rainy"
  },
  "style": {
    "art_direction": "film still",
    "color_style": "vivid neon",
    "render_style": "photorealistic",
    "inspirations": [
      "Wong Kar-wai",
      "Blade Runner neon atmosphere"
    ]
  },
  "technical": {
    "quality": "8k ultra high detail",
    "noise_grain": "light film grain",
    "post_processing": "cinematic color grading with subtle bloom"
  },
  "negative_prompt": [
    "distorted face",
    "extra limbs",
    "blurry subject",
    "incorrect anatomy",
    "overexposed neon"
  ],
  "references": {
    "images": []
  }
}
```


5. **자동 파이프라인 실행 (백엔드/워커)**
   - 아래 2.2 ~ 2.7 단계 참조

6. **완료 후**
   - Supabase에 최종 비디오 파일 메타데이터 저장
   - Frontend에서:
     - 워크스페이스 프로젝트 라이브러리 에셋(자산 관리)창에 카드로 생성 (클릭 시 모달창이 열리고, 완성본 파일을 다운로드 받을 수도 있음)
     - “완료되었습니다. 라이브러리에서 클릭 후 다운로드 버튼을 눌러 결과 영상을 받으세요.”
     - 로그/에러 요약 확인 가능
   - 사용자는 PC에서 다운로드 후 최종 편집/업로드에 활용.
   - 모바일이나 PC어디서든 작업해도 라이브러리에 저장된 데이터는 추후 (예를 들면 하루 뒤, 또는 2일 뒤) 실제 작업을 진행할 때 다운로드 받을 수 있음.
---

### 2.2 장면 분할 단계 (SCRIPT_SEGMENT)

- 입력:
  - `Script.rawText` 또는 이미 저장된 `Script.scenes`
- 출력:
  - `Script.scenes[]` 배열 (각 Scene에 `sceneId` 부여)
- 요구사항:
  - 만약 이미 Scene 구조가 있다면 **재분할 금지**, 그대로 사용.
  - 없다면:
    - 문장 단위 또는 사용자가 정의한 규칙(**오디오 음성 분량으로 5~10초 내외**)에 따라 Scene을 생성.
    - 사용자가 분할 단위를 규칙에 못 맞출 경우 자동으로 정의한 규칙대로 재분할로 도움을 줌
- 예시 Scene 구조:

```json
{
  "sceneId": 1,
  "title": "서론 - 조선시대 왕궁 입성",
  "text": "조선시대 한양, 웅장한 궁궐 앞에 사람들이 모여 있습니다...",
  "visualHint": "{
  "media_type": "image(이미지)",
  "goal": "네온 불빛 속 비 내리는 도시에서 슬픈 표정의 여성 클로즈업 시네마틱 사진",
  "description": {
    "subject": "투명 우산을 든 슬픈 표정의 젊은 여성",
    "environment": "비 내리는 밤의 네온 도시 거리",
    "mood": "감성적이고 시네마틱한 분위기"
  },
  "composition": {
    "shot_type": "클로즈업",
    "camera_angle": "아이레벨"
  },
  "camera": {
    "focal_length_mm": 85,
    "aperture": "f/1.8",
    "depth_of_field": "얕은 심도",
    "aspect_ratio": "16:9"
  },
  "lighting": {
    "time_of_day": "밤",
    "light_source": "네온사인",
    "weather": "비"
  },
  "style": {
    "render_style": "포토리얼",
    "color_style": "네온 비비드",
    "inspirations": ["왕가위 스타일"]
  },
  "technical": {
    "quality": "8k"
  },
  "negative_prompt": [
    "흐릿한 얼굴",
    "왜곡된 인체"
  ]
}
" (visualHint는 이 스크립트에서 시청자가 스토리의 맥락을 이해할 수 있는 납득이 가는 시청자가 보고싶은 장면을 묘사해야함.)
}
```

---

### 2.3 오디오 생성 단계 (TTS)

- 단계명: `TTS`
- 입력:
  - `Script.scenes[]`
  - `AutoConfig.ttsVoice`, `ttsSpeed`
- 처리:
  1. Scene 배열을 순회하며, 각 `scene.text`에 대해 **Google TTS API** 호출.
  2. 생성된 오디오 파일을 임시 스토리지에 저장.
  3. Supabase에 업로드 후 `SceneAsset.audioId`, `audioDurationSec` 저장.
  4. TTS 실패 시:
     - 최대 `N`회 재시도 (예: 3회).
     - 그래도 실패하면:
       - 해당 Scene을 스킵하거나, Job 전체를 FAIL로 종료 (설정 가능).
- 비고:
  - 기존에 이미 구현된 **오디오 생성 로직/함수**를 그대로 재사용.
  - 단, 이번에는 **Scene 단위 batch 처리**가 필요 → worker 내부에서 loop.

---

### 2.4 이미지 생성 단계 (IMAGE)

- 단계명: `IMAGE`
- 입력:
  - `Script.scenes[]`
  - `AutoConfig.imageStylePresetId`
  - 각 Scene별 `visualHint` (없으면 `scene.text`를 이용해 추출)
  - **visualHint는 이 스크립트에서 시청자가 스토리의 맥락을 이해할 수 있는 납득이 가는 시청자가 보고싶은 장면을 묘사해야함.**
- 처리:
  1. 각 Scene에 대해 이미지 생성 API 호출.
  2. 공통 스타일 프롬프트 + Scene별 키워드 조합:
     - 예시 (의사코드):

```text
[공통 스타일 프롬프트]
- 진격의 거인 스타일, 다크 판타지, 강한 명암
- 조선시대 배경, 한복, 상투, 궁녀 헤어스타일
- 한국 얼굴 특징, 동양인

[Scene 개별 프롬프트 구성]
"{공통 스타일 문구} + {scene.visualHint}"
```

  3. 생성된 이미지를 Supabase에 저장, `SceneAsset.imageId` 업데이트.
- 네거티브 프롬프트 예시:
  - "서양인, 유럽 건축, 현대 빌딩, 자동차, 로마숫자 시계" 등
- 실패 처리:
  - 재시도 후 실패시 **기본 placeholder 이미지** 사용.

---

### 2.5 비디오 생성 단계 (VIDEO)

- 단계명: `VIDEO`
- 입력:
  - `SceneAsset.imageId` (또는 텍스트 프롬프트)
  - `AutoConfig.videoStylePresetId`
  - 각 Scene의 `audioDurationSec`
- 특이사항:
  - 비디오생성은 **5초 또는 10초 단위**로만 비디오 생성가능.
- 처리 전략:
  1. `audioDurationSec` 기준으로 필요 비디오 길이 계산.
     - 예: 
       - audioDurationSec <= 5 → 5초 클립 1개
       - 5 < audioDurationSec <= 10 → 10초 클립 1개
       - 10 < audioDurationSec → 10초 클립 여러 개 생성 후 FFmpeg로 이어붙이기 + 속도조정
  2. kie.ai 비디오 생성 API 호출 (기존 구현 재사용).
  3. 생성된 비디오를 Supabase에 저장, `SceneAsset.videoId`, `videoDurationSec` 기록.
- 실패시:
  - 재시도 후 안 되면:
    - 해당 Scene을 **정지 이미지 + Ken Burns 효과(선택)** 로 대체하는 후처리 로직을 구현

---

### 2.6 오디오-비디오 싱크 조정 단계 (SYNC)

- 단계명: `SYNC`
- 목적:
  - 각 Scene별로 **오디오 길이와 비디오 길이를 최대한 자연스럽게 맞춘다.**
  - 오디오는 절대 건드리지 않고, **비디오만 조정**한다.

#### 2.6.1 기본 규칙

- `audioDurationSec` = A
- `videoDurationSec` = V

1. **V와 A의 차이가 작을 때 (예: |A - V| ≤ 2초)**
   - FFmpeg `setpts` 필터로 **속도 조정** (슬로우/패스트).
   - 예시:
     - 비디오 길이가 10초, 오디오가 12초 → 1.2배 느리게.
     - 비디오 길이가 10초, 오디오가 8초 → 0.8배 빠르게.
   - 이 정도는 시청자가 거의 눈치 못 채는 수준.

2. **A가 V보다 훨씬 길 때**
   - 10초 클립 여러 개 생성해 붙이거나,
   - 비디오를 **루프(loop)** 시켜 길이를 맞춘 뒤 마지막에 약간의 속도 조정.

3. **A가 매우 짧고 V가 길 때**
   - 비디오를 **트리밍(cut)** 해서 A 길이에 맞춘다.
- 예시 FFmpeg 의사 코드:

```bash
# 1) 속도 조정 (시간 스케일)
ffmpeg -i input.mp4 -filter:v "setpts={PTS_FACTOR}*PTS" -an temp_video.mp4

# 2) 오디오와 합치기
ffmpeg -i temp_video.mp4 -i scene_audio.wav -c:v libx264 -c:a aac -shortest scene_final.mp4
```

> `PTS_FACTOR = videoDurationSec / audioDurationSec` (실제 구현시 정확 계산 필요)

#### 2.6.2 Scene별 결과

- 최종적으로 Scene마다:
  - `scene_final_videoId` (오디오 포함된 Scene 단일 파일)
- Supabase에 업로드, 메타데이터 저장.

---

### 2.7 최종 전체 비디오 렌더링 단계 (FINAL_RENDER)

- 단계명: `FINAL_RENDER`
- 입력:
  - Scene 순서대로 정렬된 `scene_final_videoId` 목록
- 처리:
  1. Scene 순서(1,2,3,...)에 맞게 **각 Scene 비디오 파일 리스트** 생성
  2. FFmpeg `concat` 기능을 사용해 **하나의 긴 MP4 파일**로 합친다.
  3. 최종 파일을 Supabase에 업로드.
  4. 워크스페이스 Project 라이브러리에 `finalVideoId` 또는 `finalVideoUrl` 저장.
- 예시 FFmpeg concat 의사 코드:

```bash
# concat용 리스트 파일 생성 (files.txt)
file 'scene_001_final.mp4'
file 'scene_002_final.mp4'
file 'scene_003_final.mp4'
...

# concat 실행
ffmpeg -f concat -safe 0 -i files.txt -c copy final_output.mp4
```

---

## 3. UI / 와이어프레임(텍스트 설명)

### 3.1 Project 화면에 “자동 생성” 탭 추가

- 상단 탭:
  - [스크립트] [오디오] [이미지] [비디오] **[원클릭솔루션]**
- **원클릭솔루션 탭**에 들어가면:

#### 3.1.1 기본 정보 영역

- 선택된 Project 정보 표시:
  - 프로젝트 제목
  - 채널 타입(예: 한국사 채널, CCTV 공포 채널 등)
  - 현재 스크립트 존재 여부 (있음/없음)
- “스크립트 편집/보기” 버튼  
  → Script 탭으로 이동하여 수정 가능

#### 3.1.2 자동 생성 설정 폼

- **TTS 설정**
  - Voice 선택 (드롭다운)
  - 속도(Speed) 슬라이더 (0.8 ~ 1.2 정도)
- **이미지 스타일 설정**
  - 스타일 프리셋 선택 (드롭다운) (편집가능해야함)
  - (선택) 스타일 프롬프트 미리보기/편집 버튼
- **비디오 스타일 설정**
  - Seedream 공통 프롬프트 프리셋 선택
- **화면 비율**
  - 라디오 버튼: 16:9 / 9:16 / 1:1
- **테스트 모드**
  - 토글 스위치: ON → 앞 2씬만 생성(샘플)
- **비디오 생성모드**
  - 토글 스위치: ON → 이미지-투-비디오 생성, OFF → 이미지로 최종 비디오 생성
- **오류 발생 시 정책**
  - 드롭다운:
    - “실패한 Scene은 스킵하고 계속 진행”
    - “한 Scene이라도 실패하면 전체 Job 중단”

#### 3.1.3 실행 영역

- “완전자동 생성 시작” 버튼
- 버튼 클릭 시:
  - API 요청 → Job 생성
  - 버튼 비활성 + 로딩 스피너
- 진행 상태 표시:
  - 전체 Progress Bar (0~100%)
  - 현재 단계: SCRIPT_SEGMENT / TTS / IMAGE / VIDEO / SYNC / FINAL_RENDER
  - 로그 간단 요약:
    - “12/100 장면 오디오 생성 완료”
    - “이미지 생성 20/100…”

- 작업 중단: “작업 중단” 버튼

#### 3.1.4 완료/결과 영역

- 상태가 COMPLETED일 때:
  - “최종 비디오 다운로드” 버튼
  - 파일 용량 / 길이 정보
- 상태가 FAILED일 때:
  - 에러 요약 메시지
  - “자세한 로그 보기” (모달/확장영역)
  - “이전 단계까지 생성된 결과만 확인” (향후 옵션)

---

## 4. 백엔드 API & 워커 로직 설계

### 4.1 API 설계 (의사 스펙)

#### 4.1.1 POST `/api/auto/run`

- 설명: 특정 Project에 대해 완전자동 생성 Job을 시작한다.
- Request Body 예시:

```json
{
  "projectId": "proj_123",
  "autoConfigOverride": {
    "ttsVoice": "ko-KR-Standard-A",
    "ttsSpeed": 1.0,
    "imageStylePresetId": "history_korea_anime_dark",
    "videoStylePresetId": "history_seedream_v1",
    "aspectRatio": "9:16",
    "testMode": false,
    "onErrorPolicy": "skip_scene"  // or "stop_job"
  }
}
```

- Response:

```json
{
  "jobId": "auto_20251127_001",
  "status": "PENDING"
}
```

#### 4.1.2 GET `/api/auto/status/:jobId`

- 설명: Job 상태 및 진행 상황 조회.
- Response 예시:

```json
{
  "jobId": "auto_20251127_001",
  "projectId": "proj_123",
  "status": "RUNNING",
  "currentStep": "IMAGE",
  "progress": 42,
  "sceneCompleted": {
    "tts": 30,
    "image": 20,
    "video": 10,
    "sync": 5
  },
  "error": null,
  "logsPreview": [
    "[TTS] scene 1 done (4.2s)",
    "[IMAGE] scene 1 done",
    "[VIDEO] scene 1 done (10.0s)"
  ]
}
```

#### 4.1.3 POST `/api/auto/cancel/:jobId` (선택)

- 설명: RUNNING Job을 취소 요청.

---

### 4.2 Worker 파이프라인 의사 코드

```pseudo
function processAutoJob(jobId):
  job = loadJob(jobId)
  setJobStatus(job, RUNNING, step="SCRIPT_SEGMENT")

  script = loadScript(job.projectId)
  scenes = ensureScenes(script)  // 이미 있으면 재사용, 없으면 생성
  saveScenes(job.projectId, scenes)

  // TEST MODE 처리: 앞 N개만 대상으로 scenes 배열 슬라이싱
  scenesToProcess = applyTestMode(job.autoConfig, scenes)

  // 1) TTS
  setJobStep(job, "TTS")
  for scene in scenesToProcess:
    generateTTS(scene, autoConfig)
    updateProgress(job)

  // 2) IMAGE
  setJobStep(job, "IMAGE")
  for scene in scenesToProcess:
    generateImage(scene, autoConfig)
    updateProgress(job)

  // 3) VIDEO
  setJobStep(job, "VIDEO")
  for scene in scenesToProcess:
    generateVideo(scene, autoConfig)
    updateProgress(job)

  // 4) SYNC
  setJobStep(job, "SYNC")
  for scene in scenesToProcess:
    syncAudioVideo(scene)
    updateProgress(job)

  // 5) FINAL_RENDER
  setJobStep(job, "FINAL_RENDER")
  finalVideo = concatScenes(scenesToProcess)
  saveFinalVideo(job.projectId, finalVideo)

  setJobStatus(job, COMPLETED, progress=100)
```

> 각 단계에서 예외 발생 시 `onErrorPolicy`에 따라:
> - `"skip_scene"` : 해당 scene만 실패 처리 후 계속 진행
> - `"stop_job"` : 즉시 Job을 FAILED로 전환하고 종료

---

## 5. 오류 처리 / 예외 처리 / 디버깅 전략

### 5.1 공통 원칙

1. **각 Stage 단위로 명확한 경계**
   - SCRIPT_SEGMENT / TTS / IMAGE / VIDEO / SYNC / FINAL_RENDER  
   - Stage별로 시작/종료 로그를 남긴다.
2. **Scene 단위 오류**
   - 개별 Scene에서 오류가 나도 Job 전체가 죽지 않도록 옵션 제공.
3. **재시도 정책**
   - 외부 API 오류 (네트워크, 429, 5xx 등)에 대해
     - 최대 3회 재시도
     - 지수 백오프(예: 1s, 3s, 7s)
4. **로깅 구조**
   - 각 Job에 `logs` 배열을 두고, Worker가 단계별 메시지 push
   - 치명적인 에러는 `error` 필드에도 저장

### 5.2 에러 유형별 대응 예

- TTS 실패
  - 원인: 텍스트 길이 제한, API rate limit 등
  - 대응: 텍스트 길이 초과 시 자동 분할 / rate limit 시 딜레이 후 재시도
- 이미지 생성 실패
  - 원인: 프롬프트 문제, API 내부 에러
  - 대응: 네거티브 프롬프트/스타일 조금 수정 후 재시도 (향후 고도화)
  - 최종 실패시 placeholder 이미지 사용
- 비디오 생성 실패
  - 원인: Seedream API 에러, 길이 제한
  - 대응: 동일 프롬프트로 재시도, 안되면 해당 Scene만 이미지 슬라이드로 대체
- FFmpeg 단계 실패
  - 원인: 잘못된 파일 경로, 포맷 불일치
  - 대응:
    - 입력 파일 존재 여부, 포맷 사전 검증
    - 오류 코드/메시지를 로그에 상세 기록

### 5.3 디버깅 편의를 위한 설계

- `debugMode` 플래그(프로젝트/AutoConfig 단위)
  - ON일 때:
    - 외부 API 호출 request/response 메타만 별도 저장 (민감정보 제외)
    - FFmpeg 실행 커맨드 로그 남기기
- Job 상태 페이지에서:
  - 최근 50줄 로그를 UI로 보여주는 기능
  - 특정 Scene 실패시 해당 Scene ID를 눌러 상세 로그 확인 가능

---

## 5.4 추가 제안/비고사항 (Optional but 권장)

1. **스타일 프리셋 시스템**
   - 채널/프로젝트별로 스타일 프리셋을 저장: (앱에서 편집가능)
     - `imageStylePreset`
     - `videoStylePreset`
     - `ttsPreset`
   - 이렇게 하면 나중에 “한국사 채널 프리셋” / “육아 브이로그 채널 프리셋” 등 쉽게 전환 가능.

2. **비용/시간 예측 표시**
   - Job 실행 전에:
     - 예상 Scene 수
     - 예상 TTS/이미지/비디오 API 호출 횟수
     - 대략적인 소요 시간(예: 3~7분)
   - 사용자가 실행 전에 부담을 예측할 수 있게.

3. **부분 재실행 기능**
   - 특정 Scene만 다시 생성 (예: 비주얼이 마음에 안 들 때)
   - 나중에는 Scene 선택 후 “이미지만 재생성” 같은 기능으로 확장 가능.

4. **멀티 해상도 출력 옵션**
   - 최종 렌더링 시:
     - 1080p / 720p / 480p 등 옵션 추가
   - 기본값 1080p, 모바일 업로드용으로 720p도 제공 가능.

5. **샘플 모드 강력 활용**
   - testMode를 적극 활용해 1~2 Scene만 샘플로 만들어 보고
   - 스타일/톤/길이가 마음에 들면 전체 Scene로 확장 실행.

---

## 7. 정리

- 이 문서는 **기존에 이미 구현된 개별 기능(스크립트/오디오/이미지/비디오 API 연동)을 변경하지 않고**,  
  그 위에 **완전자동화 레이어**를 추가하는 것을 목표로 한다.
- 핵심 포인트:
  - Scene 단위 ID 관리
  - Stage 기반 파이프라인 (TTS → IMAGE → VIDEO → SYNC → FINAL_RENDER)
  - 오디오 길이에 맞춘 이미지 또는 비디오 길이 자동 조정 (FFmpeg)
  - 안정적인 오류 처리 및 진행 상태 표시
- 안티그래비티/개발 에이전트는 이 문서를 토대로:
  - 필요한 DB 스키마 확장,
  - API 라우트 추가,
  - Queue/Worker 로직,
  - Frontend Auto 탭 UI를 구현하면 된다.

이 문서 하나만 보고도, **“완전자동 생성 시스템”** 전체를 설계·구현할 수 있도록 최대한 구체적으로 작성되었다.  
구현 중 애매한 부분이 있을 경우, 우선은 **기존 기능을 건드리지 않는 방향**과 **Scene/Stage 기반 구조**를 유지하는 것을 최우선 원칙으로 삼는다.

**문서에 작성된 코드들은 실제 코드와 다를 수 있으며, 실제 개발시에는 기존 앱 폴더의 개발 코드를 참고해서 실제 사용이 가능한 코드로 개발한다. **
